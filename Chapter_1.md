## 열혈 자료구조 스터디

# Chaprter 1

- 자료구조와 알고리즘의 차이
    - 자료구조 : 데이터의 표현 및 저장방법 
    - 알고리즘 : 표현 및 저장된 데이터를 대상으로 하는 '문제의 해결 방법'
    
  → 결론 : 서로 의존적이다.


### 알고리즘의 성능 분석 방법
- 시간복잡도/공간복잡도
    - 시간복잡도 : 알고리즘 실행속도에 관한 것
    - 공간복잡도 : 메모리 사용량에 관한 것

- 알고리즘 수행속도 평가방법
    1) 연산의 횟수를 세기
    2) 처리해야할 데이터의 수 n에 대한 연산횟수의 함수 T(n)구성하기
        
        > 이때, T(n)을 굳이 구성하는 이유는 <br>T(n)을 통해 **데이터 수의 증가에 따른 연산횟수의 변화정도**를 파악하는 것이 가능하기 때문
       
    > Q. 어떤 알고리즘이 좋은 알고리즘인가?
    
    > A. 상황에 맞게 판단해야한다. <br> 안정적인 성능을 보장하는 알고리즘은 구현난이도가 높은 반면, 그렇지 않은 알고리즘은 구현난이도가 낮으므로, <br>데이터가 수가 많지 않고 성능에 덜 민감한 경우 구현난이도가 낮은 알고리즘을 선택한다.
  

- 시간 복잡도 분석의 핵심요소 
    1) 알고리즘마다 핵심이 되는 연산 파악하기
        - 그 연산을 줄이는 것이 시간 복잡도를 줄이는 길
    2) 시간복잡도를 따지는 기준
        - 최선의 경우(best case)
        - 최악의 경우(worst case)
        - 평균적인 경우(average case) : 제일 좋으나, 어떤게 평균적인 기준인지 명확하지 않음
        
        → 결론 : 최악의 경우로 따진다.



### 순차 탐색(Linear Search) 알고리즘과 시간 복잡도 분석의 핵심요소

```C
#include <stdio.h>

int LSearch(int ar[], int len, int target) {
	// 순차 탐색 알고리즘 적용된 함수

	int i;
	for (i = 0; i < len; i++) {
		if (ar[i] == target) {
			return i;              // 찾은 대상의 인덱스 값 반환
		} 
	}
	return -1;                    // 찾지 못했음을 의미하는 값 반환 
}

int main() {
	int arr[] = { 3, 5, 2, 4, 9 };
	int idx;
	idx = LSearch(arr, sizeof(arr) / sizeof(int), 4);
	if (idx == -1) {
		printf("탐색 실패 \n");
	}
	else {
		printf("타겟 저장 인덱스 : %d\n", idx);
	}

	idx = LSearch(arr, sizeof(arr) / sizeof(int), 7);
	if (idx == -1) {
		printf("탐색 실패\n");
	}
	else {
		printf("타겟 저장 인덱스 : %d\n", idx);
	}
	return 0;
}
```
#### 순차 탐색 알고리즘의 시간복잡도 계산하기
- 최악의 경우(worst case) : T(n) = n
- 평균적인 경우(worst case) : T(n) = (3/4)n 
   <br> (가정 1: 탐색 대상이 배열에 존재하지 않을 확률은 50% <br> 가정 2: 배열의 첫 요소부터 마지막 요소까지 탐색 대상이 존재할 확률은 동일)



### 이진 탐색(binary search) 알고리즘의 소개
- 순차탐색보다 좋은 성능이나 조건이 있음
  <br> : **데이터가 정렬되어 있어야한다**
